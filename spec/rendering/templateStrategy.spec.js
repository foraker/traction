// Generated by CoffeeScript 1.3.3
(function() {

  describe("template rendering strategy", function() {
    var createInstance;
    JST["templates/source/path"] = function() {};
    createInstance = function(options) {
      if (options == null) {
        options = {};
      }
      return new Traction.Rendering.TemplateStrategy(_.extend(options, {
        template: "source/path"
      }));
    };
    describe("shared behavior", function() {
      return jasmine.itShouldBehaveLike("a node rendering strategy", {
        createInstance: createInstance
      });
    });
    it("assigns its element", function() {
      var element, renderer;
      element = $("<div></div>")[0];
      renderer = createInstance({
        renderWithin: element
      });
      return expect(renderer.el).toEqual(element);
    });
    it("finds the JST template function source", function() {
      var renderer, templateFunction;
      templateFunction = function() {};
      JST["templates/source/path"] = templateFunction;
      renderer = createInstance();
      return expect(renderer.template).toBe(templateFunction);
    });
    describe("#call", function() {
      beforeEach(function() {
        this.element = $("<div>original content</div>")[0];
        this.renderer = createInstance({
          renderWithin: this.element
        });
        return this.renderer.template = function() {
          return "templated content";
        };
      });
      it("empties the existing node contents", function() {
        this.renderer.call();
        return expect(this.element.innerHTML).not.toContain("original content");
      });
      it("calls the template function with the correct options", function() {
        spyOn(this.renderer, "template");
        this.renderer.call();
        return expect(this.renderer.template).toHaveBeenCalledWith({
          outlet: this.renderer.buildOutlet
        });
      });
      it("appends the results of the template function", function() {
        this.renderer.call();
        return expect(this.element.innerHTML).toContain("templated content");
      });
      describe("bindings", function() {
        beforeEach(function() {
          this.binding = {
            bindTo: function() {
              return this;
            }
          };
          return spyOn(Traction.Bindings, "Factory").andReturn(this.binding);
        });
        it("creates bindings for data-bind attributes", function() {
          this.renderer.template = function() {
            return "<p data-bind='attribute'></p>";
          };
          this.renderer.call();
          return expect(Traction.Bindings.Factory).toHaveBeenCalledWith(this.renderer.$("p")[0], "attribute");
        });
        it("registers the binding", function() {
          this.renderer.template = function() {
            return "<p data-bind='attribute'></p>";
          };
          this.renderer.call();
          return expect(this.renderer.bindings).toEqual([this.binding]);
        });
        it("creates multiple bindings for multiple tag", function() {
          this.renderer.template = function() {
            return "<p id='first' data-bind='attribute-one'></p>\n<p id='second' data-bind='attribute-two'></p>";
          };
          this.renderer.call();
          expect(Traction.Bindings.Factory).toHaveBeenCalledWith(this.renderer.$("p#first")[0], "attribute-one");
          return expect(Traction.Bindings.Factory).toHaveBeenCalledWith(this.renderer.$("p#second")[0], "attribute-two");
        });
        it("creates multiple bindings for a single tag", function() {
          this.renderer.template = function() {
            return "<p data-bind='attribute-one attribute-two'></p>";
          };
          this.renderer.call();
          expect(Traction.Bindings.Factory).toHaveBeenCalledWith(this.renderer.$("p")[0], "attribute-one");
          return expect(Traction.Bindings.Factory).toHaveBeenCalledWith(this.renderer.$("p")[0], "attribute-two");
        });
        return it("binds the factoried binding to the bindTo option", function() {
          var model;
          spyOn(this.binding, "bindTo");
          this.renderer.template = function() {
            return "<p data-bind='attribute'></p>";
          };
          model = {};
          this.renderer.call({
            bindTo: model
          });
          return expect(this.binding.bindTo).toHaveBeenCalledWith(model);
        });
      });
      return describe("outletting", function() {
        it("outlets all children", function() {
          var child;
          this.renderer.template = function() {
            return "<script data-outlet=''></script>";
          };
          child = {
            el: "<p>child content</p>"
          };
          this.renderer.call({
            children: {
              childName: child
            }
          });
          return expect(this.renderer.el.innerHTML).toEqual("<p>child content</p>");
        });
        return it("can outlet specific children", function() {
          var child1, child2;
          this.renderer.template = function() {
            return "<script data-outlet='child1'></script>\n<span><script data-outlet='child2'></script></span>";
          };
          child1 = {
            el: "<p>Child 1 Content</p>"
          };
          child2 = {
            el: "<p>Child 2 Content</p>"
          };
          this.renderer.call({
            children: {
              child1: child1,
              child2: child2
            }
          });
          return expect(this.renderer.el.innerHTML).toEqual("<p>Child 1 Content</p>\n<span><p>Child 2 Content</p></span>");
        });
      });
    });
    return describe("#buildOutlet", function() {
      var renderer;
      renderer = createInstance();
      it("returns a script tag with the correct data attribute", function() {
        var markup;
        markup = renderer.buildOutlet("child");
        return expect(markup).toBe("<script data-outlet='child'></script>");
      });
      return it("default the name of the child to an empty string", function() {
        var markup;
        markup = renderer.buildOutlet();
        return expect(markup).toBe("<script data-outlet=''></script>");
      });
    });
  });

}).call(this);
