// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  describe("Rails model", function() {
    describe("initialization", function() {
      it("allows the paramRoot to be specified", function() {
        var TestModel;
        TestModel = (function(_super) {
          __extends(TestModel, _super);

          function TestModel() {
            return TestModel.__super__.constructor.apply(this, arguments);
          }

          TestModel.prototype.paramRoot = "test";

          return TestModel;

        })(Traction.Rails.Model);
        return expect(new TestModel().paramRoot).toBe("test");
      });
      it("infers the paramRoot when unspecified", function() {
        var Namespace;
        Namespace = {};
        Namespace.UserComment = (function(_super) {
          __extends(UserComment, _super);

          function UserComment() {
            return UserComment.__super__.constructor.apply(this, arguments);
          }

          return UserComment;

        })(Traction.Rails.Model);
        return expect(new Namespace.UserComment().paramRoot).toBe("user_comment");
      });
      return it("does not infer the paramRoot when the model is a Traction.Rails.Model", function() {
        return expect(new Traction.Rails.Model().paramRoot).toBe(void 0);
      });
    });
    describe("error parsing", function() {
      beforeEach(function() {
        return this.item = new Traction.Rails.Model;
      });
      it("parses the response errors", function() {
        var json;
        json = JSON.stringify({
          errors: {
            name: 'is invalid'
          }
        });
        this.item.trigger("error", this.item, {
          responseText: json
        });
        return expect(this.item.errors).toEqual({
          name: "is invalid"
        });
      });
      return it("handles responses without errors", function() {
        return this.item.trigger("error", this.item, {
          responseText: null
        });
      });
    });
    describe("#toJSON", function() {
      it("returns model attributes", function() {
        var model;
        model = new Traction.Rails.Model({
          name: "name"
        });
        return expect(model.toJSON()).toEqual({
          name: "name"
        });
      });
      return describe("when persistable attributes are defined", function() {
        return it("only return specified attributes", function() {
          var TestModel, model;
          TestModel = (function(_super) {
            __extends(TestModel, _super);

            function TestModel() {
              return TestModel.__super__.constructor.apply(this, arguments);
            }

            TestModel.prototype.persists = ['name'];

            return TestModel;

          })(Traction.Rails.Model);
          model = new TestModel({
            name: "name",
            email: "email@example"
          });
          return expect(model.toJSON()).toEqual({
            name: "name"
          });
        });
      });
    });
    return describe("#patch", function() {
      beforeEach(function() {
        this.instance = new Traction.Rails.Model({
          first_name: "initial first",
          last_name: "initial last"
        });
        this.instance.changed = false;
        return spyOn(this.instance, "sync");
      });
      it("only persists changed attributes", function() {
        this.instance.set({
          last_name: "updated_last"
        });
        this.instance.patch();
        return expect(this.instance.sync).toHaveBeenCalledWith('update', this.instance, {
          attrs: {
            last_name: "updated_last"
          }
        });
      });
      return it("respects a paramRoot", function() {
        this.instance.paramRoot = "user";
        this.instance.set({
          last_name: "updated_last"
        });
        this.instance.patch();
        return expect(this.instance.sync).toHaveBeenCalledWith('update', this.instance, {
          attrs: {
            user: {
              last_name: "updated_last"
            }
          }
        });
      });
    });
  });

}).call(this);
