// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  describe("Rails model", function() {
    describe("initialization", function() {
      it("allows the paramRoot to be specified", function() {
        var TestModel;
        TestModel = (function(_super) {

          __extends(TestModel, _super);

          function TestModel() {
            return TestModel.__super__.constructor.apply(this, arguments);
          }

          TestModel.prototype.paramRoot = "test";

          return TestModel;

        })(Traction.Rails.Model);
        return expect(new TestModel().paramRoot).toBe("test");
      });
      it("infers the paramRoot when unspecified", function() {
        var Namespace;
        Namespace = {};
        Namespace.UserComment = (function(_super) {

          __extends(UserComment, _super);

          function UserComment() {
            return UserComment.__super__.constructor.apply(this, arguments);
          }

          return UserComment;

        })(Traction.Rails.Model);
        return expect(new Namespace.UserComment().paramRoot).toBe("user_comment");
      });
      return it("does not infer the paramRoot when the model is a Traction.Rails.Model", function() {
        return expect(new Traction.Rails.Model().paramRoot).toBe(void 0);
      });
    });
    describe("#set", function() {
      var User;
      User = (function(_super) {

        __extends(User, _super);

        function User() {
          return User.__super__.constructor.apply(this, arguments);
        }

        User.prototype.associations = {
          comments: Backbone.Collection,
          profile: Backbone.Model
        };

        return User;

      })(Traction.Rails.Model);
      beforeEach(function() {
        return this.user = new User({
          name: "Test User",
          comments: [
            {
              content: "comment 1"
            }
          ],
          comments_url: "/comments"
        });
      });
      describe("creating associations", function() {
        it("assigns attributes", function() {
          return expect(this.user.get("name")).toBe("Test User");
        });
        it("maps the associated attribute to the correct class", function() {
          return expect(this.user.get("comments")).toBeInstanceOf(Backbone.Collection);
        });
        it("assigns the correct attributes to the association", function() {
          return expect(this.user.get("comments").first().get("content")).toBe("comment 1");
        });
        it("assign a URL when present", function() {
          return expect(this.user.get("comments").url).toBe("/comments");
        });
        return it("handles multiple associations", function() {
          var user;
          user = new User({
            profile: {}
          });
          return expect(user.get("profile")).toBeInstanceOf(Backbone.Model);
        });
      });
      describe("updating associations", function() {
        it("sets associated model attributes", function() {
          this.user.set({
            name: "new name"
          });
          return expect(this.user.get("name")).toBe("new name");
        });
        it("sets associated collection contents", function() {
          this.user.set({
            comments: []
          });
          return expect(this.user.get("comments").models).toEqual([]);
        });
        it("retains the updated association", function() {
          this.user.set({
            comments: []
          });
          return expect(this.user.get("comments")).toBeInstanceOf(Backbone.Collection);
        });
        it("does not remove associations when the attribute has not been specified", function() {
          var originalCollection;
          originalCollection = this.user.get("comments");
          this.user.set();
          return expect(this.user.get("comments")).toBe(originalCollection);
        });
        it("removes associations when the attribute is undefined", function() {
          this.user.set({
            comments: void 0
          });
          return expect(this.user.get("comments")).toBe(void 0);
        });
        it("sets setable (model) associations", function() {
          this.user.set({
            profile: {
              type: "admin"
            }
          });
          return expect(this.user.get("profile").get("type")).toBe("admin");
        });
        it("emits a change event", function() {
          var callback;
          callback = jasmine.createSpy();
          this.user.on("change:comments", callback);
          this.user.set({
            comments: []
          });
          return expect(callback).toHaveBeenCalled();
        });
        it("emits a change event when the association is removed", function() {
          var callback;
          callback = jasmine.createSpy();
          this.user.on("change:comments", callback);
          this.user.set({
            comments: null
          });
          return expect(callback).toHaveBeenCalled();
        });
        it("does not emit a change event when silent: true is passed", function() {
          var callback;
          callback = jasmine.createSpy();
          this.user.on("change:comments", callback);
          this.user.set({
            comments: []
          }, {
            silent: true
          });
          return expect(callback).not.toHaveBeenCalled();
        });
        it("does not emit a change event when the association is unchanged", function() {
          var callback;
          this.user.set({
            profile: {
              type: "admin"
            }
          });
          callback = jasmine.createSpy();
          this.user.on("change:profile", callback);
          this.user.set({
            profile: {
              type: "admin"
            }
          });
          return expect(callback).not.toHaveBeenCalled();
        });
        return it("does not emit a change event when the lack of an association is unchanged", function() {
          var callback;
          this.user.set({
            profile: null
          });
          callback = jasmine.createSpy();
          this.user.on("change:profile", callback);
          this.user.set({
            profile: null
          });
          return expect(callback).not.toHaveBeenCalled();
        });
      });
      it("handles attr, val style setting", function() {
        this.user.set("name", "Timothy");
        return expect(this.user.get("name")).toBe("Timothy");
      });
      return it("does not mutate the attributes", function() {
        var orignalAttributes;
        orignalAttributes = {
          comments: []
        };
        this.user.set(orignalAttributes);
        return expect(orignalAttributes).toEqual({
          comments: []
        });
      });
    });
    describe("#url", function() {
      return it("returns the 'url' attribute", function() {
        var model;
        model = new Traction.Rails.Model({
          url: "/items"
        });
        return expect(model.url()).toBe("/items");
      });
    });
    describe("error parsing", function() {
      beforeEach(function() {
        return this.item = new Traction.Rails.Model;
      });
      it("parses the response errors", function() {
        var json;
        json = JSON.stringify({
          errors: {
            name: 'is invalid'
          }
        });
        this.item.trigger("error", this.item, {
          responseText: json
        });
        return expect(this.item.errors).toEqual({
          name: "is invalid"
        });
      });
      return it("handles responses without errors", function() {
        return this.item.trigger("error", this.item, {
          responseText: null
        });
      });
    });
    describe("#toggle", function() {
      return it("inverts an attribute", function() {
        var model;
        model = new Traction.Rails.Model({
          admin: true
        });
        model.toggle('admin');
        return expect(model.get("admin")).toBe(false);
      });
    });
    return describe("#toJSON", function() {
      it("returns model attributes", function() {
        var model;
        model = new Traction.Rails.Model({
          name: "name"
        });
        return expect(model.toJSON()).toEqual({
          name: "name"
        });
      });
      return describe("when persistable attributes are defined", function() {
        return it("only return specified attributes", function() {
          var TestModel, model;
          TestModel = (function(_super) {

            __extends(TestModel, _super);

            function TestModel() {
              return TestModel.__super__.constructor.apply(this, arguments);
            }

            TestModel.prototype.persists = ['name'];

            return TestModel;

          })(Traction.Rails.Model);
          model = new TestModel({
            name: "name",
            email: "email@example"
          });
          return expect(model.toJSON()).toEqual({
            name: "name"
          });
        });
      });
    });
  });

}).call(this);
