// Generated by CoffeeScript 1.9.3
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Traction.Rails.Model = (function(superClass) {
    extend(Model, superClass);

    function Model() {
      return Model.__super__.constructor.apply(this, arguments);
    }

    Model.prototype.associations = {};

    Model.prototype.initialize = function() {
      if (!this._isBaseClass()) {
        this.paramRoot || (this.paramRoot = this._inferParamRoot());
      }
      return this.on("error", this.parseErrors, this);
    };

    Model.prototype.set = function(key, value, options) {
      var newAttributes;
      if (typeof key === "object") {
        newAttributes = _.clone(key);
        options = value;
      } else {
        newAttributes = {};
        newAttributes[key] = value;
      }
      this._setAssociations(newAttributes, options || {});
      return Model.__super__.set.call(this, newAttributes, options);
    };

    Model.prototype.parseErrors = function(self, response) {
      var ref;
      return this.errors = (ref = $.parseJSON(response.responseText)) != null ? ref.errors : void 0;
    };

    Model.prototype.toggle = function(attribute) {
      return this.set(attribute, !this.get(attribute));
    };

    Model.prototype.url = function() {
      return this.get("url") || Model.__super__.url.apply(this, arguments);
    };

    Model.prototype.toJSON = function() {
      var attribute, i, json, len, ref;
      if (this.persists) {
        json = {};
        ref = this.persists;
        for (i = 0, len = ref.length; i < len; i++) {
          attribute = ref[i];
          json[attribute] = this.get(attribute);
        }
        return json;
      } else {
        return Model.__super__.toJSON.apply(this, arguments);
      }
    };

    Model.prototype._inferParamRoot = function() {
      return _.string.underscored(this._className());
    };

    Model.prototype._className = function() {
      return this.constructor.toString().match(/function\s(.*?)\(/)[1].toString();
    };

    Model.prototype._isBaseClass = function() {
      return this.constructor === Traction.Rails.Model;
    };

    Model.prototype._setAssociations = function(attributes, options) {
      var associationName, isDirty, klass, newValue, previousValue, ref, results, urlRoot;
      ref = this.associations;
      results = [];
      for (associationName in ref) {
        klass = ref[associationName];
        newValue = attributes[associationName];
        if (previousValue = this.get(associationName)) {
          if (!(associationName in attributes)) {
            continue;
          }
          isDirty = this._updateAssociation(klass, associationName, newValue);
          if (isDirty && !options.silent) {
            this.trigger("change:" + associationName, previousValue);
          }
        } else {
          this._createAssociation(klass, associationName, newValue);
        }
        delete attributes[associationName];
        if (urlRoot = attributes[associationName + "_url"]) {
          results.push(this.get(associationName).url = urlRoot);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Model.prototype._createAssociation = function(klass, name, newValue) {
      if (newValue instanceof klass) {
        return this.attributes[name] = newValue;
      } else {
        newValue = new klass(newValue);
        return this.attributes[name] = newValue;
      }
    };

    Model.prototype._updateAssociation = function(klass, name, newValue) {
      var dirtyCheck, isDirty;
      isDirty = false;
      dirtyCheck = (function(_this) {
        return function(cb) {
          var callback;
          callback = function() {
            return isDirty = true;
          };
          _this.get(name).on("change add remove", callback);
          cb();
          return _this.get(name).off("change add remove", callback);
        };
      })(this);
      if (newValue instanceof klass || !newValue) {
        if (this._isCollection(this.get(name)) && this._isCollection(newValue)) {
          dirtyCheck((function(_this) {
            return function() {
              return _this.attributes[name].set(newValue.models);
            };
          })(this));
        } else {
          isDirty = newValue !== this.get(name);
          this.attributes[name] = newValue;
        }
      } else {
        dirtyCheck((function(_this) {
          return function() {
            return _this.get(name).set(newValue);
          };
        })(this));
      }
      return isDirty;
    };

    Model.prototype._isCollection = function(collection) {
      return collection != null ? collection.models : void 0;
    };

    return Model;

  })(Backbone.Model);

}).call(this);
